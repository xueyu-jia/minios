# 说明

本文就 miniOS v2.0.0 及其前继版本 v1.5.3 进行整体概述，主要涉及以下方面：

- 新版本的特性
- 旧版本的漏洞
- 版本升迁的遗留问题

> 虽说是概述，其实总有些较为复杂的情况要展开叙述。

不过由于这三个方面的某些环节可能存在交叉，故下文并不对其分开描述，而是会以同一类问题为主线作混合描述。

此外，以下所有陈述均指向 arch-x86 的 i386 实现，毕竟若是不出预料的话，v2.0.0 应该还没有引入对其他架构的支持。

# 关于 bootloader

## 关于 floppy

各种意义上，现存的 floppy 实现并不可用。

**文件系统**

使用老旧的 fat12，这与当前架构的 image-setup fs-support 等诸多流程并不兼容。

**程序的有效性**

floppy 的执行流程并未验证，原构建实际也并未提供从 floppy boot 的方式。

## 关于 mbr

此处主要指代 mbr 格式的 bootloader 实现。

**mbr 程序**

构建系统换代后，旧的 mbr 程序表现异常，无法搜索到活跃分区，故换用了新的 mbr，与之相比，新的实现少了对拓展分区的支持。

**boot 程序**

旧有的 fat32 boot 过于冗余可怖，完全没有字节剩余，对其功能进行分析后，替换了新的实现，初步判断对功能无影响；若有需要请回滚对比。

另一方面，在 mbr 与 fat32 boot 替换的同时，并未对原有的 orangefs boot 进行检查，不建议使用；若有需要的话请自行验证其与 fat32 boot 功能的一致性并作进一步检验。

**boot 分区**

旧有的 bootloader 在 mbr 程序中决定一次 boot partition 再在 loader 中重新扫描分区表得到 boot partition 来判断当前的分区，当默认按第一个 bootable partition 启动时，该策略无误，但两次 boot partition 的独立却无法避免不一致情形的产生。如通过 grub 等 bootloader 进行二次引导，从而实际启动的分区并非必然是第一个活跃分区，而可以是任意一个，此时造成当前引导分区的误判。

在新的实现中 loader 接收 partition lba 作为 start 参数之一，对应当前引导分区的起始位置。在此实现中，partition lba 由 mbr 程序得到，并通过 boot 一直传递到 loader。

**文件读写**

旧版本中存在 kernel 大于 1M 时 bootloader 崩溃的情形，该问题主要出自两个方面：

1. 默认的 bootfs 只给定了 1M，装载 kernel.bin 时并未检验分区容量从而导致文件损坏
2. loader 实现的 fat32 读写操作未对待操作的剩余长度做截断，而是直接递减簇大小，导致无符号减时长度溢出，读写异常

对于后者，新版本将其截断为实际读取大小（当然使用 ssize_t 也是可行的，且更推荐）以保证正确性；对于前者，仅调整 bootfs 至 8M，但并未作额外处理，该方面仍需进一步完善。

## 关于输出

对于 legacy 启动模式，在实模式下，用户几乎不必在意硬件而仅需粗暴使用中断服务即可。

实模式下，输出向 VGA 显存写入，这一点被保留。

但在保护模式下，新版本舍弃了显存操作而使用 UART COM1 串口进行输出，同时 loader 中的 gs 与 video selector 也被移除。

做出这一点变动主要有两个原因：

- 旧版本的 bootloader 对于内存检测及配置的实现有着较为严重的漏洞，若保留 VGA，难以通过自洽、不突兀的实现修复该漏洞（详情见[关于内存](#关于内存)）
- VGA 显存实际是 MMIO 映射的内存区域，该内存区间并不能由 `int 15h` 的系统内存映射查询服务得到，而这会导致支持 VGA 就必须要容忍一项特立独行的硬编码或相对较重的显卡驱动配置，与之相比，仅需 Port IO 就能够实现输出且配置较为简单的 UART 设备要优越的多

对应的，包括显卡在内的各类设备都得以在内核密集而一致地得到配置。

就事实而言，对于相对较难调试的 bootloader，通过串口输出日志远比写显存要易于观察；当然，在真机环境中，串口反而倾向于使调试变得复杂，但对于目前短小的 bootloader 实现，不足秒的 boot 过程，即使在屏幕上看不到输出也并非无法容忍的事。

# 关于内存

## 关于内存检测

**检测与记录**

内存检测由 bootloader 通过 15h 中断的 [Query System Memory Map](https://uefi.org/specs/ACPI/6.5/15_System_Address_Map_Interfaces.html#e820-assumptions-and-limitations) 服务实现。该服务枚举包括接入的 RAM 的内存和 BIOS 保留内存在内的一系列内存地址区间，然而 PCI 设备等若干来源映射的地址区间并不被囊括，除此之外，标准 PC 的地址区间也被排除在外，而在这之中就包含了 VGA 显存 **0xa0000\~0xbffff**。

很显然，通过此途径检测的内存并不完整，或者说对于纯粹地检测可用 RAM 已经够用。

对于一般情况，查询得到的 ARDS 列表包含低地址处（包含中断向量表等）与 1M 处共计两处可用内存地址区间，而这两段之间存在着若干保留区域。

> 在这里，1M 是 i386 架构 boot 过程中标准的一处可用内存基址，这意味着只要 ARDS 从 1M 处起始，该区域总是一段可用内存。

旧的实现取最大 ARDS 的结束地址为可用内存的结束地址，而使其从 0 处开始，这使得检测到的可用于内核内存分配的内存实际上覆盖了多处不应当被读写的内存，或者说，这些内存并不如内存检测所预期的那样可以被用户随意读写——这使得参与映射与分配的内存与实际可用于该用途的内存不一致，包括尺寸与权限。

在新的实现中，本着 **只做职责之内的事** 这一原则，loader 仅按基址升序排列，取得从中断服务得到的所有 ARDS 可用内存区间。

需要注意的是，对于其他 arch——包括 x86_64——关于 1M 是否仍旧是标准的可用内存基址，并未作进一步确认。但是可以预料到，至少对于 64-bit 的架构，这一点应当是倾向于不成立的。

另一方面，根据相关资料，部分处理器上 1M 处并非是最后一块 RAM。而为了观察多块内存的检测结果，v2.0.0 在 QEMU 仿真中预置了 4 块热插拔的 DIMM 设备，对于此类 RAM，先前中断服务并未检测得到，推断仍需借助 DIMM 驱动以实现。

关于内存检测方法仍需进一步改良。

**内存测试**

旧的实现中，loader 先从中断服务得到可用内存区间再对这些区间的每一个物理页的最后一个双字做字节反转读写的测试以验证其是否可用。

听上去很合理，而我最初也是这样理解的——主板只告知哪些地方是 RAM，但并不保证这些内存没有损坏，反转读写测试则做了验证内存是良好的一环，以此来筛出实际上不可用的“可用内存”。

这就是吃了知识储备不足而纯粹在代码间学习的坏处——这做法根本就是糟糕、无效的。

通过查找[资料](https://wiki.osdev.org/Detecting_Memory_(x86))得知这两种方法其实分别是实模式与保护模式探测可用内存的一种实现方式，而比起前者，后者粗暴、缓慢且危险，且并不会得到更好的结果。相较之而言，中断服务已经良好地给出了真正可用的内存区间。

这个事实为我带来了糟糕的体验，一方面是上文所提到的，另一方面则是内存测试会覆盖到 loader 正在运行的内存区间，这导致我不得不野蛮地硬编码默认该内存是可用的从而使测试例程跳过该区间。

> 实际上，依据资料，loader 所在的 0x090000\~0x100000 处即便是按照原思路也并非需要检测，因为低地址的 1MB 总是被倾向于被依赖为是有效的。

新版本中，仅保留了中断服务的内存检测过程，剔除了多余的实现。但仍需注意现有检测默认得到的 ARDS list 是升序且不重叠的，实际上这两点可能并不会被保证。

## 关于内存映射

旧版本在 loader 中按照最大 ARDS 区间的大小对从 0 处开始的该大小区间的内存进行连续映射，导致实际检验的可用内存与映射的内存产生了 ARDS 基址的偏移，这是个严重的错误。

此外，旧有的 FMIBuff，也即该死的 Free Memory Info Buffer 的糟糕的缩写（这还是通过搜索 github 从其他 miniOS 项目中的注释中找到的），通过记录测试后有效的内存页面的地址阈限以表示可用的地址区间集合。该种表示方法丢失了包括但不限于起始地址、内存大小的大量信息，且在后续使用中变本加厉地忽略了更多的信息而直接根据尾部的地址界限来定义总的物理内存大小，这样的操作使得内存检测的意义被极大压缩，且埋下了访存的诸多隐患。

> 值得一提的是，这种粗暴豪横的处理方法使得先前的维护者留下了“如何得到总的页面个数”这样的疑问，而这却分明是在内存检测中已经明确得到了的数据，如今却被写下如此代码的人自己给舍弃掉了。

新版本已重置为为每一项可用 RAM 作页表映射，且将对应结构变更为更精确的表示形式。

## 关于布局

loader 的页表映射策略为 pa 映射为 pa 及 pa+3G，旧版本中，kernel elf 起始地址被定位在 va 0xc0120400，也即 pa 1M+129K 处，而页目录与页表则从 1M 处开始分配。

显然，i386 完整地址空间映射需要 1M+4K 空间预留给页表，而旧的内存布局终将导致 kernel elf 加载时对页表的覆写。

这对我造成了很大的麻烦。出现问题时，比起静下心来全面排查，我更倾向于从局部的蛛丝马迹入手以求快速解决问题，这导致我与最终使得 kernel elf 在加载崩溃时所处在的 fat32_read 做了长久的斗争。诚然，过程中确实发现了 fat32_read 的重大问题，可这并没有让问题得到解决，直到我最终在这一个小角落意识到除了内存出问题再无其他可能，才终于尝试分析页表映射情况从而寻得了问题症结。

新版本将 kernel elf 起始地址调整到物理地址 3M 处，从而保证低 1~3M 对页表够用。

当然，这仅仅是 loader 的情况，除此之外仍需注意该映射依旧是硬编码的，物理 1\~3M 并未在程序逻辑上得到保证，尽管 1M 位置被标记为一个可靠的 RAM 起始地址，并且我也在 loader 中额外做出了可用内存至少为 8M 的断言，但仍旧无法排除部分机型上在 1~3M 处存在内存空洞的情况。

同时，出于相同的考虑，因为 loader 的页表在 GB 以下完全是等值映射，故而可能出现的内存空洞同样会导致线性地址不连续，在这之中，首当其冲的就是 kernel elf 的加载。只是由于当前代码大量的依赖于 ±3G 来实现内核态物理地址与线性地址的相互转换，目前也只能对该漏洞睁一只眼闭一只眼。

> 这里为什么是 8M 呢？因为在解决这个问题之前，8M 是在 2^n M 内存中第一个使得 miniOS 能够正常运行的大小。尽管在这之后 4M 也同样能胜任，但不管怎样，8M 还是更为合理。

另一个需要提及的是，kernel elf 指定的起始地址最终落实为 .text 段基址，尽管 ld 默认将 text 置为第一个 section，但还是那句老话，程序逻辑（此处指代向 ld 传递的参数）并没有保证这件事，这样的默认实际上也是一个需要警惕的 UB。

## 关于该死的内存分配

在旧的版本中，buddy 把内核本身所在的页面分配了出去。

这很好笑，听上去也很容易察觉，但就是这么短短一句话耗费了我 6 个小时的时间，从内存检测到内存布局到 buddy 可用页面标记到 kernel buffer 初始化到 buddy 内存分配到 slab 内存分配到 slab 对象创建到 buddy 页面分配到注意到 memory overlaps，方才拍板定位到某个玄妙无比，糟糕至极的 pf 的产生原因。

> 事实上，pf 仅仅只是指内核最终由 page fault 结束崩溃，而仅仅是该 page fault 也是以一个异常的形式陷入而非走的正常的 page fault handler；另一方面，即便是注意到该崩溃由 pf 收尾，这项发现也并未带来任何帮助。在追溯过程中，即使是对可能出现问题的代码进行调整甚至等价替换，都引起了崩溃发生现场的剧变。
>
> 当然，或许在代码等价替换却造成结果不同时就该注意到问题症结在于内核被破坏，但是很遗憾我并不具备如此敏锐的洞察力与强悍的执行力。

这个动作很糟糕，但实际上，发现这个错误正是[关于内存](#关于内存)整个大节的最终目的——在旧版本中，存在超过 32M 内存时会引起崩溃的问题，而其原因尚不明朗。这个漏洞的发现无疑会对该问题的解决作出重大贡献。

解决方案实际也非常简单，正如 [关于内存映射](#关于内存映射) 中提到的，之前的维护者因为丢弃了关于物理页的信息而陷入需要却不得的困境，最终只能盲目硬编码一个魔术常量来逃避这个问题。

我的意思是，buddy 的错误源自于信息的不足。因为信息不足，所以内存布局模糊不清，所以一刀切处理。bootloader 能够为 loader 带来足够的信息，kernel 覆盖的内存空间同样在这之中。处理它，只需要扩大 kernel 初始化时对系统状态的知情权就行。

当然，这还不够，仅仅送入完整内存分布并不能一次性解决问题。旧版本该死的 buddy 实现合理却又不合适地将硬编码内存区间连续标记为可用页面——这意味着即使存在内存空洞也会被 buddy 忽略，它只会按照传入参数地那一对 begin/end 参数连续处理——故而还需对 buddy 初始化做额外修改。

新版本中保留 buddy 初始化的基本框架，将 begin/end 连续映射重定义为内存界限，而根据 loader 送入的 free memory info 将界限内的各内存区间分别截断映射。

除此之外，为了处理 kernel overlaps 的问题在 loader 中取 kernel elf va 页面对齐的界限，将其从已经扫描完成并建立页表后的 free memory info 中排除。

> 这让我想起 uniform，事实上类似的问题早在 uniform 中就处理过了，当时的解决方案是使用 GCC 提供的 \_end 符号标定 critical memory，从而使可分配内存跳过 kernel。如今想来也是闲置太久了，导致已经处理过的问题又再一次从零被处理。

# 关于中断

## 临时关中断

旧版本中实现为 `cli ... sti`，该实现并未考虑中断原本的启用状态。一个显著的例子是 kernel\_main 原本被期望全程关中断（初始化 fs 除外，这需要等待硬盘中断以完成操作），但在 restart 之前却依旧进了未知中断而引发 GP。排查后发现是 tty 初始化过程进行了显存读写，而在此相关操作 out_char 中应用了先关后开的代码块，导致 tty 初始化完成后中断保持在了启用状态，进而导致 kernel\_main 预期之外陷入中断例程。

新的实现使用一对进行状态复原的关-开中断方法替代了几乎全部的临时关中断操作，以防止对原中断状态的破坏。其中，仅对中断状态确定的部分可不必使用该方法，如 kernel\_main 中初始化完 fs 后中断一定是要禁用的，亦或者调度时中断总是屏蔽的，诸如此类。
