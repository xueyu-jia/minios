# 已知及偶然性的测例失败项待办列表

- [ ] ipc 之后执行 proc 测例概率因 page fault 终止

该现象共出现过两次，分别位于 exit 与 fork 测例，其中 fork 测例中产生的 page fault 位于 rq_insert 的空指针成员偏移访问，对应变量未知。

重复五六次尝试复现，复现无果，故在此记录。

- [ ] ls 操作概率导致崩溃重启

原始描述：无

最新描述：修复 vfs 问题时发现 vfs 较为脆弱，几乎每一次因漏洞而失败的 fs 操作都会导致在这之后的 fs 操作失败，包括但不限于崩溃重启、并发读写原子性测试失败、page fault 等等。经过相关修复后该项错误可能一并解决，已长期未触发该现象，但暂时无法确定。

- [ ] 执行 fs 测例后执行 proc 测例概率导致崩溃重启

该现象首次出现的场景为：疯狂执行 fs 测例并全数通过，在这之后紧接着执行 proc 测例系统崩溃重启后，在这之后继续执行 proc 测例依旧崩溃重启，在这之后等待若干秒后再执行 proc 测例运行正常。

重新仿真模拟上述过程，未能复现。

情景补充：在 v2.3.0.beta.1 版本下启动仿真常规速度先执行 fs 测例再执行 proc，出现崩溃重启现象。

- [ ] 非实时调度队列结构失效导致断言失败

具体指代 kernel/sched.c:is_rq_empty 中的关于队列判空的断言，该错误在多个高并发场景下均曾出现。

- [ ] 内存过大时系统启动失败

当内存大小大于等于 1004.5 MiB 时，AHCI Controller 异常，报错 `error: ahci mode not supported`，于 bootloader 加载内核失败导致系统启动失败。

其中 1004 MiB 启动成功，为最大可启动内存。

调试结果：ahci controller 的 mmio 在本实现中等值映射在 0xfebf1000，当达到 1005 MiB 后该线性地址将提前被映射在内核空间，导致 mmio 的映射失败，随后对设备的访问实际落在 ram 上而非设备内存空间。

解决方案：

**方案一**

在 1MiB\~3GiB 之间随便找个线性地址映射到设备地址。

**方案二**

若已经映射，替换原页表项完成设备配置，在内核加载完成后跳入内核前回滚该操作。

注意事项：kernel 里完成的 ahci 设备初始化也是一样，记得要改。

- [ ] dentry 死锁 / hd\_service 死锁

反复运行 proc 测例约一个半小时后，Execve.WaitAfterExecve 测试项的 33、36 和 38 号进程在 /bin/execve 的 bin 目录项上死锁，其中 33、36 号进程在 kern\_execve 下打开文件下层的 get\_dentry 处死锁，同时 38 号进程位于 hd\_rdwt\_sched 的 wait\_event(&hdque)，获得锁者为 38 号进程。

其中 38 号进程在 kern\_execve /bin/execve 下的  vfs\_put\_dentry bin 下的 vfs\_sync\_inode 下直到 wait\_event(&hdque)，该进程在 wait\_event(&hdque) 主动 sched\_yield 前被调度走且始终未被唤醒。对应的，此时 hd\_service 进程正在 ksem\_wait(&hdque_full, 1)。

备注：该问题暂时仅出现过一次。

- [ ] slab 分配的对象无法释放

反复随机运行测例，概率在 ipc 测例 的 MsgQueueSend.WaitUntil 测试项中的子进程 msgctl 中的 pop_front_msg_node 中触发。

具体地，pop_front_msg_node 中的 phy\_kfree 从 slab 中尝试释放对象，在 slab\_free 中的查找对象循环中始终无法在 cache 的 partial/full 的 slab 链中找到对应对象，继而无限重复尝试失败。

在这过程中测例仅父子进程，且父进程处于 wait 睡眠状态等待子进程结束。

情景补充：在以上情景的复现中再次调试，发现待释放对象 0xc4f70040 位于 cache 的 empty 链的第 2 个 slab 0xc4f70000 中，对应 slab 位图标记和总对象数均为 0，结构未损坏，可猜测该地址被二次释放。

警告：若以上提及的二次释放成立，则原使用处可能使用了已经释放的内存，这将导致不可预期的错误。

- [x] fs 相关操作的耗时随运行时长增加而显著增加

反复随机运行测例一小时及以上，fs 测例运行耗时从百毫秒级暴涨至十秒级，对于约一小时处的运行结果，耗时翻了将近七十倍。

严格来说这并非测例 NG，但是考虑到问题过于严重，不得不将其视为需要修复/优化的紧急待办项。

解决方案：不需要解决，出现该问题的原因是原测例在 /tmp 创建文件但是并不删除，越来越慢纯属是 tmp 文件太多了，在 fat32 impl 中找文件找空位啥的操作耗时变长。在 shell 每次执行完测例里手动清 /tmp 再跑一小时随机测例，得到 fs 的运行时长始终稳定在 \~180ms，可以得到验证。
