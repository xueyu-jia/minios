# 已知及偶然性的测例失败项待办列表

- [ ] ipc 之后执行 proc 测例概率因 page fault 终止

该现象共出现过两次，分别位于 exit 与 fork 测例，其中 fork 测例中产生的 page fault 位于 rq_insert 的空指针成员偏移访问，对应变量未知。

重复五六次尝试复现，复现无果，故在此记录。

- [ ] ls 操作概率导致崩溃重启

原始描述：无

最新描述：修复 vfs 问题时发现 vfs 较为脆弱，几乎每一次因漏洞而失败的 fs 操作都会导致在这之后的 fs 操作失败，包括但不限于崩溃重启、并发读写原子性测试失败、page fault 等等。经过相关修复后该项错误可能一并解决，已长期未触发该现象，但暂时无法确定。

- [ ] 执行 fs 测例后执行 proc 测例概率导致崩溃重启

该现象首次出现的场景为：疯狂执行 fs 测例并全数通过，在这之后紧接着执行 proc 测例系统崩溃重启后，在这之后继续执行 proc 测例依旧崩溃重启，在这之后等待若干秒后再执行 proc 测例运行正常。

重新仿真模拟上述过程，未能复现。

情景补充：在 v2.3.0.beta.1 版本下启动仿真常规速度先执行 fs 测例再执行 proc，出现崩溃重启现象。

- [ ] 非实时调度队列结构失效导致断言失败

具体指代 kernel/sched.c:is_rq_empty 中的关于队列判空的断言，该错误在多个高并发场景下均曾出现。

- [ ] 内存过大时系统启动失败

当内存大小大于等于 1004.5 MiB 时，AHCI Controller 异常，报错 `error: ahci mode not supported`，于 bootloader 加载内核失败导致系统启动失败。

其中 1004 MiB 启动成功，为最大可启动内存。

调试结果：ahci controller 的 mmio 在本实现中等值映射在 0xfebf1000，当达到 1005 MiB 后该线性地址将提前被映射在内核空间，导致 mmio 的映射失败，随后对设备的访问实际落在 ram 上而非设备内存空间。

解决方案：

**方案一**

在 1MiB\~3GiB 之间随便找个线性地址映射到设备地址。

**方案二**

若已经映射，替换原页表项完成设备配置，在内核加载完成后跳入内核前回滚该操作。

注意事项：kernel 里完成的 ahci 设备初始化也是一样，记得要改。

- [ ] dentry 死锁 / hd\_service 死锁

反复运行 proc 测例约一个半小时后，Execve.WaitAfterExecve 测试项的 33、36 和 38 号进程在 /bin/execve 的 bin 目录项上死锁，其中 33、36 号进程在 kern\_execve 下打开文件下层的 get\_dentry 处死锁，同时 38 号进程位于 hd\_rdwt\_sched 的 wait\_event(&hdque)，获得锁者为 38 号进程。

其中 38 号进程在 kern\_execve /bin/execve 下的  vfs\_put\_dentry bin 下的 vfs\_sync\_inode 下直到 wait\_event(&hdque)，该进程在 wait\_event(&hdque) 主动 sched\_yield 前被调度走且始终未被唤醒。对应的，此时 hd\_service 进程正在 ksem\_wait(&hdque_full, 1)。
