<div align='center'> 
<h1>MiniOS VFS 改造重构说明</h1>
v0.4 姜峰 2024.3.11
</div>

## 数据结构与接口定义
### 文件系统公共数据结构
``` c
#define MAX_DNAME_LEN 32
struct super_block{
	union {
	  struct xxx_sb_info xxx_sb;//实例文件系统私有数据
	  ...
	};
	/*
   * the following item(s) are only present in memory
   */
  	struct vfs_dentry* sb_root;
	list_head sb_inode_list; 
	//双向链表头,记录这个sb已经使用的所有有效inode,用于查找已有的inode,互斥性由inode_alloc_lock维护
	struct superblock_operations * sb_op; //操作函数
	int sb_dev; 	/**< the super block's home device */
	int fs_type;	// 文件系统类型，数值上与hdinfo[]一致, 同时作为fstype_table[]的索引
	int used;
	struct spinlock lock;
}

struct vfs_inode{
	u32 i_no; // 索引节点编号，同一个超级块内唯一
	struct super_block* i_sb; // 超级块指针
	u32 i_rdev;   // real device
	u32 i_b_cdev; // (for special inode) block/char device
	u32 i_nlink; // inode 硬链接数
	atomic_t i_count; // inode使用计数,dentry中的引用占用一次
	u32 i_size;  // 文件大小,字节数
	int i_type;  // 类型，如 char/block/dir...
	int i_mode;  // 读、写、执行权限 ==> I_R/W/X
	u32 i_atime; // access time (UTC timestamp, 下同)
	u32	i_ctime; // create time
	u32 i_mtime; // modify time
	struct inode_operations *i_op; 
	// inode 操作函数, 用于在目录下查找/创建/删除文件或目录
	struct file_operations *i_fop; // inode 对应的File操作函数，用于读写等操作
	union {
		struct xxx_inode_info xxx_inode; 
		//实例文件系统私有数据，xxx表示实例文件系统的名字
		...
	};
	struct list_node i_list; // recently used inodes list,
	// 通过此结构连接到sb的inode链表或者vfs的空闲inode链表
	struct spinlock lock; 
	//自旋锁，更改inode（不包含i_count)以及对应文件磁盘内容时持有
};

struct vfs_dentry{
	atomic_t d_count; // 目录项引用计数，文件查找过程中、打开和关闭时修改
	char d_name[MAX_DNAME_LEN];
	struct vfs_inode* d_inode;//dentry引用的inode,保证在VFS树形缓存中连接的目录项有效
	struct vfs_dentry* d_nxt;//当前层级目录项双向链表指针域
	struct vfs_dentry* d_pre;
	struct vfs_dentry* d_subdirs; //文件夹目录项有效,指向下级目录项链表的头
	struct vfs_dentry* d_parent; //上级目录,对于所在文件系统的根目录项,其值为本身
	struct vfs_mount* d_vfsmount; //目录项所在的挂载点信息, 如果位于根文件系统，其值为空
	int d_mounted; // 是否为挂载点
	struct dentry_operations * d_op; //dentry操作函数，用于比较
	struct spinlock lock; //自旋锁，更改dentry（不包含d_count)时持有
};

struct file_desc {
	int	flag;	//用于标志描述符是否被使用
	int	fd_mode;	/**< R or W */
	atomic_t fd_count;	/**用于维护进程间相同File引用的资源释放*/
	int	fd_pos;		/**< Current position for R/W. */
	struct vfs_dentry *fd_dentry; //文件的目录项
	struct file_operations* fd_ops; //读写等操作函数
};

struct dirent{//readdir相关,用于描述dir内容
	int d_ino;
	char d_name[MAX_DNAME_LEN];
};

struct dirstream{
	struct file_desc* file;
	int init;
	int count;//readdir系统调用 已经读取的目录项个数
	int total;
};
#define DIR_DATA(dirp) ((struct dirent*)((dirp) + 1))

typedef struct dirstream DIR;

struct fs_type{
	char * fstype_name; // 如，"Orange", "FAT32"
	struct file_operations * fs_fop;
	struct inode_operations * fs_iop;
	struct superblock_operations * fs_sop;
	struct dentry_operations * fs_dop;
};

struct vfs_mount{
	struct vfs_dentry * mnt_dev; //设备文件所在目录项
	struct vfs_dentry * mnt_mountpoint; //挂载点(挂载前的文件夹目录项)
	struct vfs_dentry * mnt_root;//挂载的文件系统根
	struct super_block* mnt_sb;
	int used;
};

// ***内存对象***
// mount.c
struct vfs_mount mnt_table[NR_MNT];//每一项对应一处挂载点
// vfs.c
struct file_desc f_desc_table[NR_FILE_DESC];//对应每一次打开的文件(不同进程不同)
struct super_block super_blocks[NR_SUPER_BLOCK];//超级块,
struct fs_type fstype_table[NR_FS_TYPE]; //每一项对应一种文件系统类型
struct vfs_dentry *vfs_root;

// vfs 内部变量
static list_head inode_free_list; //vfs_inode空闲链表
static u32 inode_free_cnt; //vfs_inode空闲链表长度
static struct spinlock inode_alloc_lock;//用于实现分配vfs_inode的互斥
static struct spinlock file_desc_lock;//用于实现分配文件结构体的互斥

```

### VFS核心函数实现机制及重要功能实现
#### 重要功能实现
+ vfs_lookup: 查找一个文件/目录,返回相应dentry
根据路径名解析逐级的文件/目录名,每解析得到一层目录的字符串进行一层查找，如果中途任意一层发现找不到相应的dentry则返回NULL
在每一层的查找中：（对应_do_lookup函数的实现）
如果是"."，则返回当前dentry, 如果是"..",则先检查挂载信息，如果是挂载的文件系统根，则找到对应的挂载点的d_parent dentry,否则返回当前dentry的d_parent
如果不是上述情况，则先在dentry缓存中查找,若找不到则调用实例文件系统inode operations中的lookup查找,仍然找不到则返回NULL
+ vfs_create: 创建一个文件/目录/设备文件,返回创建的dentry
根据传入参数的不同,调用实例文件系统的create/mkdir,对于设备文件设置设备文件的信息
+ struct vfs_inode * vfs_new_inode(struct super_block* sb)
给相应超级块分配一个新的inode,VFS将其自动加入superblock的inode链表中
+ struct vfs_inode * vfs_get_inode(struct super_block* sb, int ino)
根据superblock和inode号获取inode, 如果superblock的inode链表找不到对应inode,则通过VFS分配一个新的，再调用实例文件系统的read_inode方法初始化,最后将目标inode更新到superblock链表头并返回inode指针 
此方法增加inode的引用计数
+ vfs_put_inode: 减少一个inode的引用计数,如果引用计数自减后>0,什么也不做, 否则:
1. 检查inode的i_nlink,如果为0则说明经过之前的unlink操作已经不再有inode引用此文件,只是当时还有进程使用,此时最后的使用引用计数(i_count)也已经释放,所以调用实例文件系统的delete_inode删除文件的磁盘空间
2. 调用实例文件系统的put_inode并释放内存资源
+ vfs_put_dentry: 减少一个dentry的引用计数，如果减1之后为0，则：
检查dentry中的inode是否为NULL（无效inode）,如果无效则释放dentry的内存
+ struct vfs_dentry * vfs_new_dentry(const char* name, struct vfs_inode* inode);
分配一个新的dentry连接到inode, 名字是name

说明：在vfs中， inode, dentry, file_desc 三种数据结构均存在引用计数，
其中的关系是：inode的引用全部来自dentry, dentry的引用来自file_desc或者pcb中的cwd
#### VFS的内存使用及管理
所有inode和dentry内存分配通过kern_kmalloc和kern_kfree函数完成
为避免频繁的内存分配操作，VFS使用空闲链表inode_free_list维护至多一定数量MAX_FREE_INODE_OBTAIN(目前设置为32)的已释放不用的inode空间，下次vfs_new_inode分配新的inode时优先从空闲链表取出一个进行分配使用。
同时，当put_inode释放不用的inode时，如果空间链表长度计数小于MAX_FREE_INODE_OBTAIN，则将此inode放到空闲链表缓存，不进行实际的空间释放操作
dentry 的内存在inode lookup查找或create/mkdir操作之后申请，删除文件/目录时如果不再使用此dentry则释放相应dentry的内存
### 系统调用相关接口及VFS实现
+  open/creat:(创建并)打开文件
int open(const char* pathname, int flags);
int open(const char* pathname, int flags, int mode);
int creat(const char *pathname, int mode); 
pathname:要打开文件的路径,flags:打开标志,mode:创建文件的权限
打开一个文件, 如果flags中包含O_CREAT,则传入参数必须提供mode参数,否则会取得用户栈中的随机数据传入mode
成功返回int文件描述符,否则返回-1
注:根据POSIX标准, creat(pathname, mode) 等价于 open(pathname, O_CREAT|O_WRONLY, mode)
VFS实现: 
	1. 找到一个可用的fd
	2. VFS进行lookup查找,得到所在目录的dentry和目标文件的dentry,如果flags中含有O_CREAT标志,则通过vfs_create创建普通文件
	3. 找到一个File结构并初始化, 填入相应的dentry和操作函数, 填入fd处的指针
+ close:关闭一个打开的文件
int close(int fd);
VFS实现:
	1. 通过fd获得相应的File结构
	2. File引用数自减,如果减为0则: 执行vfs_put_dentry, 清空File内容
	3. 进程File指针置为空
+ read/write:读写文件
int read(int fd, void *buf, int count);
int write(int fd, const void *buf, int count);
从fd文件读数据, 至多读写count字节, 读写成功返回实际的读写字节数
VFS实现:
	1. 通过fd取得File指针
	2. 通过file_operations 调用相应实例文件系统的read/write
+ lseek:
int lseek(int fd, int offset, int whence);
根据offset和whence参数调整fd文件描述符位置
VFS实现: 略
注: 目前尚无实例文件系统需要自定义lseek的实现,以后的实例文件系统如有需要再在file_operations中添加
+ unlink: 删除一个文件名
+ rmdir: 删除一个空目录
+ mkdir: 创建一个空目录
int unlink(const char *pathname);
int rmdir(const char *pathname);
int mkdir(const char *pathname, int mode);
参数 pathname 为目标文件/目录的路径, mkdir中mode是创建文件夹授予的权限, mode信息是否保存在相应磁盘取决于相应实例文件系统的实现
VFS实现:
	1. 调用vfs_lookup等函数找到所在上级目录和目标文件/目录的dentry
	2. 调用对应的实例文件系统实现
	3. 实例文件系统操作正确, 更新VFS信息, mkdir将创建的目录dentry插入VFS查找路径, unlink和rmdir则删除对应的dentry

## 实例文件系统实现说明
### VFS向实例文件系统提供的接口
+ struct vfs_inode * vfs_new_inode(struct super_block* sb)
给相应超级块分配一个新的inode,VFS将其自动加入superblock的inode链表中
+ struct vfs_inode * vfs_get_inode(struct super_block* sb, int ino)
根据superblock和inode号获取inode, 如果superblock的inode链表找不到对应inode,则通过VFS分配一个新的，再调用实例文件系统的read_inode方法初始化,最后将目标inode更新到superblock链表头并返回inode指针 
此方法增加inode的引用计数
+ struct vfs_dentry * vfs_new_dentry(const char* name, struct vfs_inode* inode);
分配一个新的dentry连接到inode, 名字是name
### 实例文件系统操作函数接口（由实例文件系统实现）
除非特殊说明,所有操作函数的互斥操作全部由VFS处理,实例文件系统无需对相应数据结构上锁
```c
struct inode_operations{
	struct vfs_dentry * (*lookup)(struct vfs_inode *dir, const char *filename);
	int (*create)(struct vfs_inode *dir, struct vfs_dentry *dentry, int mode);
	int (*unlink)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*mkdir)(struct vfs_inode *dir, struct vfs_dentry *dentry, int mode);
	int (*rmdir)(struct vfs_inode *dir, struct vfs_dentry *dentry);
};
```
+ lookup: 在dir中查找名为filename的文件/目录, 如果找到了,通过调用VFS接口获取有效inode、初始化新的dentry并返回, 否则返回空
+ create/mkdir: 在dir中创建文件/目录,dentry中保存要创建的文件/目录名, dentry中inode为NULL, 如果创建成功, 由实例文件系统调用VFS接口分配新的inode并进行初始化, mode为要创建的文件/目录权限
+ unlink/rmdir: 删除文件/目录, 如果目录非空则删除失败, 传入有效的所在文件夹inode和要删除的文件/目录dentry
create/unlink/mkdir/rmdir 操作成功时返回0，失败返回-1
```c
struct dentry_operations{
	int (*compare)(const char *dentryname, const char *filename);
};
```
+ compare: **可选**操作函数, 用于指定VFS进行lookup操作进行文件名比较, 名称匹配时返回0, 若实例文件系统没有提供此函数, dentry名称匹配采用strcmp严格匹配
```c
struct file_operations{
	int (*read)(struct file_desc *file, unsigned int count, char * buf);
	int (*write)(struct file_desc *file, unsigned int count, const char * buf);
	int (*readdir)(struct file_desc *file, unsigned int count, struct dirent* start);
};
```
+ read: 读数据操作函数,count是要读取的字节数，返回成功读入的字节数,
+ write: 写数据操作函数, count是要写入的字节数，返回写回的字节数,并根据需要更新inode
+ readdir: 读取文件夹内所有文件/目录，至多count个目录项
上述三个函数在调用前持有对应inode锁
```c
struct superblock_operations{
	int (*fill_superblock)(struct super_block *, int);
	int (*write_inode)(struct vfs_inode *inode);
	void (*read_inode)(struct vfs_inode *inode);
	void (*put_inode)(struct vfs_inode* inode);
	void (*delete_inode)(struct vfs_inode* inode);
};
```
+ fill_superblock: 初始化及mount文件系统时调用, 读取相应实例文件系统的超级块, 实例文件系统需要调用VFS接口初始化根dentry, 读取正确返回0
+ write_inode: inode信息变更时调用, 将有效inode写入磁盘, 写入成功返回0
+ read_inode: 从磁盘读入inode, inode中superblock和inode号已经指定
+ put_inode: VFS中put_inode操作至inode引用计数归0时调用, 实例文件系统需要释放inode中私有数据动态分配的空间
如果实例文件系统在inode中没有需要释放的内存资源，可以不实现此接口
+ delete_inode: 用于文件删除, 当inode引用计数为0，且不再引用文件时(nlink为0)时调用, 实例文件系统实现相应文件磁盘空间的回收 
### 如何开发一个实例文件系统
1. 

## 参考与备注
[Linux v2.6.24](https://github.com/torvalds/linux/tree/v2.6.24)
[POSIX.1-2008](https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/)