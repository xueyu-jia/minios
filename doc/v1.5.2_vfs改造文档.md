# MiniOS VFS& FAT32 改造重构说明
## 数据结构与接口定义
``` c
// 部分数据结构沿用旧名称,代码中部分旧属性还没有修改,待最终完成测试通过一并整理
// fs_misc.h ***文件系统通用结构***
struct super_block{
	union {
	  struct xxx_sb_info xxx_sb;//实例文件系统私有数据
	  ...
	};
	int sb_dev; 	/**< the super block's home device */
	int fs_type;	//数值上与hdinfo[]一致, 同时作为fs_table[]的索引，定义上与linux的文件系统类型一致
	int used;
	struct spinlock lock;
}

struct vfs_inode{
	u32 i_no;
	struct super_block* i_sb;
	u32 i_dev; // tty字符设备文件使用(此时i_sb为空)
	u32 i_count; // 引用计数,可能是进程打开使用或是dentry引用
	u32 i_nlink; // inode引用的文件数, 用于unlink一个正在打开的文件,删除操作将会在文件关闭,inode回收时检测到i_nlink为0时执行
	u32 i_size; // 文件大小, 由实例文件系统维护
	int i_type; // 数值上沿用Orange i_mode,表示inode类型
	u32 i_mnt_index; //挂载点信息,用于确定挂载的文件系统实例
	struct inode_operations *i_op;// lookup初始化或挂载时更改,一般是对应fs_type的默认操作函数,tty则使用另外的操作函数
	struct file_operations *i_fop;
	union{
	  struct xxx_inode_info xxx_inode;
	  ...
	}
	struct vfs_inode* lru_nxt;
	struct vfs_inode* lru_pre;
	struct spinlock lock;
}vfs_inode;

struct file_desc {
	int		fd_mode;	/**< open mode */
	int		fd_pos;		/**< Current position for R/W. */
	struct  vfs_inode *fd_inode;
	int 	flag;	//用于标志描述符是否被使用
};
struct file_desc {
	int		fd_mode;	/**< R or W */
	int		fd_pos;		/**< Current position for R/W. */
	//struct inode*	fd_inode;	/**< Ptr to the i-node */	//deleted by mingxuan 2019-5-17
	
	//added by mingxuan 2019-5-17
	union 	ptr_node fd_node;
	struct vfs_inode *fd_inode;
	int 	flag;	//用于标志描述符是否被使用
	int 	dev_index;
};

struct inode_operations{
	struct vfs_dentry * (*lookup)(struct vfs_inode *dir, char *filename);
	int (*create)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*unlink)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*mkdir)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*rmdir)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*rename)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*readdir)(struct vfs_inode *dir);
	int (*put_inode)(struct vfs_inode* inode);
};

struct dentry_operations{
	int (*compare)(struct vfs_dentry *dentry, char *filename);
};

struct file_operations{
	int (*read)(struct file_desc *, unsigned int, char *);
	int (*write)(struct file_desc *, unsigned int, char *);
};

struct superblock_operations{
	int (*fill_superblock)(struct super_block *, int);
};

struct fs{
	char * fstype_name; // 如，"Orange", "FAT32"
	struct file_operations * fs_fop;
	struct inode_operations * fs_iop;
	struct super_operations * fs_sop;
}

struct vfs{
	struct file_operations * fs_fop;
	struct inode_operations * fs_iop;
	struct super_operations * fs_sop;//这里多复制了一份
	struct super_block *sb;		
	int used;
};

struct vfs_mount{
	char mnt_point_path[MAX_PATH];
	struct vfs_dentry * mnt_root;
	u32 vfs_index;
    u32 dev;
	int used;
};

// ***内存对象***
// mount.c
PUBLIC vfs_mount mnt_table[];//每一项对应一处挂载点
// vfs.c
PUBLIC struct vfs  vfs_table[NR_FS];//每一项对应一个文件系统实例(不同设备)
PUBLIC struct file_desc f_desc_table[NR_FILE_DESC];//对应每一次打开的文件(不同进程不同)
PUBLIC struct super_block super_blocks[NR_SUPER_BLOCK];//超级块,
PUBLIC struct fs fs_table[NR_FS_TYPE]; //每一项对应一种文件系统类型
PRIVATE vfs_inode vfs_inode_table[NR_INODE]; //全局inode table
// 注：vfs_inode中的联合体已经给各自的文件系统留了位置,实例文件系统的私有数据inode已有相应空间，不用另外分配
#define INODE_BMAP_SIZE (NR_INODE/8)
PUBLIC char vfs_bmap[INODE_BMAP_SIZE]; //位图,用于分配全局inode
struct vfs_dentry *vfs_root;

// vfs 内部变量
PRIVATE SPIN_LOCK inode_alloc_lock;//用于实现分配vfs_inode的互斥
PRIVATE SPIN_LOCK file_desc_lock;//用于实现分配文件结构体的互斥

// 系统调用相关接口,遵从或部分简化自POSIX标准

```
说明：


## 实例文件系统实现的说明


注: 此文档可能随开发修正
## 参考
[Linux v0.98:/include/linux/fs.h](https://elixir.bootlin.com/linux/0.98/source/include/linux/fs.h)
[POSIX.1-2008](https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/)