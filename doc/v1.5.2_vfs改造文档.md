<div align='center'> 
<h1>MiniOS VFS 改造重构说明</h1>
v0.2 姜峰 2024.2.11
</div>

## 数据结构与接口定义
### 文件系统公共数据结构
``` c
#define MAX_DNAME_LEN 32
struct super_block{
	union {
	  struct xxx_sb_info xxx_sb;//实例文件系统私有数据
	  ...
	};
	/*
   * the following item(s) are only present in memory
   */
  	struct vfs_dentry* sb_root;
	struct vfs_inode* sb_lru_list; //双向链表头,记录这个sb已经使用的所有有效inode,用于查找已有的inode,互斥性由inode_alloc_lock维护
	struct superblock_operations * sb_op; //操作函数
	int sb_dev; 	/**< the super block's home device */
	int fs_type;	//数值上与hdinfo[]一致, 同时作为fstype_table[]的索引，定义上与linux的文件系统类型一致
	int used;
	struct spinlock lock;
}

struct vfs_inode{
	u32 i_no;
	struct super_block* i_sb;
	u32 i_dev; // for char/block special inode
	u32 i_nlink; // 引用的文件数
	atomic_t i_count; // inode使用计数,dentry中的引用占用一次
	u32 i_size;  // 文件大小,字节数
	int i_type;  // char/blk/dir...
	int i_mode;  // permission ==> I_R/W/X
	struct inode_operations *i_op;
	struct file_operations *i_fop;
	union {
		struct xxx_inode_info xxx_inode; //实例文件系统私有数据
		...
	};
	struct vfs_inode* lru_nxt;// used in sb->sb_lru_list: last recently used inodes
	struct vfs_inode* lru_pre;
	struct spinlock lock;
};

struct vfs_dentry{
	char d_name[MAX_DNAME_LEN];
	struct vfs_inode* d_inode;//dentry引用的inode,保证在VFS树形缓存中连接的目录项有效
	struct vfs_dentry* d_nxt;//当前层级目录项双向链表指针域
	struct vfs_dentry* d_pre;
	struct vfs_dentry* d_subdirs; //文件夹目录项有效,指向下级目录项链表的头
	struct vfs_dentry* d_parent; //上级目录,对于所在文件系统的根目录项,其值为本身
	struct vfs_mount* d_vfsmount; //目录项所在的挂载点信息, 如果位于根文件系统，其值为空
	int d_mounted; // 是否为挂载点
	struct dentry_operations * d_op;
	struct spinlock lock;
};

struct file_desc {
	int	flag;	//用于标志描述符是否被使用
	int	fd_mode;	/**< R or W */
	atomic_t fd_count;	/**用于维护进程间相同File引用的资源释放*/
	int	fd_pos;		/**< Current position for R/W. */
	struct vfs_dentry *fd_dentry;
	struct file_operations* fd_ops;
};

struct dirent{//readdir相关,用于描述dir内容
	int d_ino;
	char d_name[MAX_DNAME_LEN];
};

struct dirstream{
	struct file_desc* file;
	int init;
	int count;//readdir系统调用 已经读取的目录项个数
	int total;
};
#define DIR_DATA(dirp) ((struct dirent*)((dirp) + 1))

typedef struct dirstream DIR;

struct fs_type{
	char * fstype_name; // 如，"Orange", "FAT32"
	struct file_operations * fs_fop;
	struct inode_operations * fs_iop;
	struct superblock_operations * fs_sop;
	struct dentry_operations * fs_dop;
};

struct vfs_mount{
	struct vfs_dentry * mnt_dev; //设备文件所在目录项
	struct vfs_dentry * mnt_mountpoint; //挂载点(挂载前的文件夹目录项)
	struct vfs_dentry * mnt_root;//挂载的文件系统根
	struct super_block* mnt_sb;
	int used;
};

// ***内存对象***
// mount.c
struct vfs_mount mnt_table[NR_MNT];//每一项对应一处挂载点
// vfs.c
struct file_desc f_desc_table[NR_FILE_DESC];//对应每一次打开的文件(不同进程不同)
struct super_block super_blocks[NR_SUPER_BLOCK];//超级块,
struct fs_type fstype_table[NR_FS_TYPE]; //每一项对应一种文件系统类型
struct vfs_dentry *vfs_root;

// vfs 内部变量
static struct spinlock inode_alloc_lock;//用于实现分配vfs_inode的互斥
static struct spinlock file_desc_lock;//用于实现分配文件结构体的互斥

```
### VFS与实例文件系统操作函数接口
除非特殊说明,所有操作函数的互斥操作全部由VFS处理,实例文件系统无需对相应数据结构上锁
```c
struct inode_operations{
	struct vfs_dentry * (*lookup)(struct vfs_inode *dir, const char *filename);
	int (*create)(struct vfs_inode *dir, struct vfs_dentry *dentry, int mode);
	int (*unlink)(struct vfs_inode *dir, struct vfs_dentry *dentry);
	int (*mkdir)(struct vfs_inode *dir, struct vfs_dentry *dentry, int mode);
	int (*rmdir)(struct vfs_inode *dir, struct vfs_dentry *dentry);
};
```
+ lookup: 在dir中查找名为filename的文件/目录, 如果找到了,通过调用VFS接口获取有效inode、初始化新的dentry并返回, 否则返回空
+ create/mkdir: 在dir中创建文件/目录,dentry中保存要创建的文件/目录名, dentry中inode为NULL, 如果创建成功, 由实例文件系统调用VFS接口分配新的inode并进行初始化, mode为要创建的文件/目录权限
+ unlink/rmdir: 删除文件/目录, 如果目录非空则删除失败, 传入有效的所在文件夹inode和要删除的文件/目录dentry
create/unlink/mkdir/rmdir 操作成功时返回0，失败返回-1
```c
struct dentry_operations{
	int (*compare)(const char *dentryname, const char *filename);
};
```
+ compare: 可选操作函数, 用于指定VFS进行lookup操作进行文件名比较, 名称匹配时返回0, 若实例文件系统没有提供此函数, dentry名称匹配采用strcmp严格匹配
```c
struct file_operations{
	int (*read)(struct file_desc *file, unsigned int count, char * buf);
	int (*write)(struct file_desc *file, unsigned int count, const char * buf);
	int (*readdir)(struct file_desc *file, struct dirent* start);
};
```
+ read: 读数据操作函数,返回读入的字节数,
+ write: 写数据操作函数,返回读入的字节数,并根据需要更新inode
+ readdir: 读取文件夹内所有文件/目录
上述三个函数在调用前持有对应inode锁
```c
struct superblock_operations{
	int (*fill_superblock)(struct super_block *, int);
	int (*write_inode)(struct vfs_inode *inode);
	void (*read_inode)(struct vfs_inode *inode);
	void (*put_inode)(struct vfs_inode* inode);
	void (*delete_inode)(struct vfs_inode* inode);
};
```
+ fill_superblock: 初始化及mount文件系统时调用, 读取相应实例文件系统的超级块, 实例文件系统需要调用VFS接口初始化根dentry, 读取正确返回0
+ write_inode: inode信息变更时调用, 将有效inode写入磁盘, 写入成功返回0
+ read_inode: 从磁盘读入inode, inode中superblock和inode号已经指定
+ put_inode: VFS中put_inode操作至inode引用计数归0时调用, 实例文件系统需要释放inode中私有数据动态分配的空间
+ delete_inode: 用于文件删除, 当inode引用计数为0，且不再引用文件时(nlink为0)时调用, 实例文件系统实现相应文件磁盘空间的回收 

### VFS核心函数实现及向实例文件系统提供的接口
#### 重要功能实现
+ vfs_lookup: 查找一个文件/目录,返回相应dentry
首先在dentry缓存中查找,若找不到则调用实例文件系统inode operations中的lookup查找,仍然找不到则返回NULL
+ vfs_create: 创建一个文件/目录/设备文件,返回创建的dentry
根据传入参数的不同,调用实例文件系统的create/mkdir,对于设备文件设置设备文件的信息
+ vfs_put_inode: 减少一个inode的引用计数,如果引用计数自减后>0,什么也不做, 否则:
1. 检查inode的i_nlink,如果为0则说明经过之前的unlink操作已经不再有inode引用此文件,只是当时还有进程使用,此时最后的使用引用计数(i_count)也已经释放,所以调用实例文件系统的delete_inode删除文件的磁盘空间
2. 调用实例文件系统的put_inode并释放内存资源

#### VFS向实例文件系统提供的接口
+ struct vfs_inode * vfs_new_inode(struct super_block* sb)
给相应超级块分配一个新的inode,VFS将其自动加入superblock的inode链表中
+ struct vfs_inode * vfs_get_inode(struct super_block* sb, int ino)
根据superblock和inode号获取inode, 如果superblock的inode链表找不到对应inode,则通过VFS分配一个新的，再调用实例文件系统的read_inode方法初始化,最后将目标inode更新到superblock链表头并返回inode指针 
此方法增加inode的引用计数
+ struct vfs_dentry * vfs_new_dentry(const char* name, struct vfs_inode* inode);
分配一个新的dentry连接到inode, 名字是name
### 系统调用相关接口及VFS实现
+  open/creat:(创建并)打开文件
int open(const char* pathname, int flags);
int open(const char* pathname, int flags, int mode);
int creat(const char *pathname, int mode); 
pathname:要打开文件的路径,flags:打开标志,mode:创建文件的权限
打开一个文件, 如果flags中包含O_CREAT,则传入参数必须提供mode参数,否则会取得用户栈中的随机数据传入mode
成功返回int文件描述符,否则返回-1
注:根据POSIX标准, creat(pathname, mode) 等价于 open(pathname, O_CREAT|O_WRONLY, mode)
VFS实现: 
	1. 找到一个可用的fd
	2. VFS进行lookup查找,得到所在目录的dentry和目标文件的dentry,如果flags中含有O_CREAT标志,则通过vfs_create创建普通文件
	3. 找到一个File结构并初始化, 填入相应的dentry和操作函数, 填入fd处的指针
+ close:关闭一个打开的文件
int close(int fd);
VFS实现:
	1. 通过fd获得相应的File结构
	2. 执行vfs_put_inode
	3. 执行fput(File引用数自减,如果减为0则将File标记为未使用), 进程File指针置为空
+ read/write:读写文件
int read(int fd, void *buf, int count);
int write(int fd, const void *buf, int count);
从fd文件读数据, 至多读写count字节, 读写成功返回实际的读写字节数
VFS实现:
	1. 通过fd取得File指针
	2. 通过file_operations 调用相应实例文件系统的read/write
+ lseek:
int lseek(int fd, int offset, int whence);
根据offset和whence参数调整fd文件描述符位置
VFS实现: 略
注: 目前尚无实例文件系统需要自定义lseek的实现,以后的实例文件系统如有需要再在file_operations中添加
+ unlink: 删除一个文件名
+ rmdir: 删除一个空目录
+ mkdir: 创建一个空目录
int unlink(const char *pathname);
int rmdir(const char *pathname);
int mkdir(const char *pathname, int mode);
参数 pathname 为目标文件/目录的路径, mkdir中mode是创建文件夹授予的权限, mode信息是否保存在相应磁盘取决于相应实例文件系统的实现
VFS实现:
	1. 调用vfs_lookup等函数找到所在上级目录和目标文件/目录的dentry
	2. 调用对应的实例文件系统实现
	3. 实例文件系统操作正确, 更新VFS信息, mkdir将创建的目录dentry插入VFS查找路径, unlink和rmdir则删除对应的dentry

## 参考与备注
[Linux v2.6.24](https://github.com/torvalds/linux/tree/v2.6.24)
[POSIX.1-2008](https://pubs.opengroup.org/onlinepubs/9699919799.2008edition/)